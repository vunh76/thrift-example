// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "tcoin.h"
#include <protocol/TBinaryProtocol.h>
#include "thrift/server/TNonblockingServer.h"
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include "thrift/concurrency/ThreadManager.h"
#include "thrift/concurrency/PosixThreadFactory.h"
#include "thrift/concurrency/Mutex.h"
#include "../tcoin_dal.h"
#include <libconfig.h++>
#include <unistd.h>

using namespace apache::thrift;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace apache::thrift::server;
using namespace apache::thrift::concurrency;

using boost::shared_ptr;

using namespace tcoin::v2;
using namespace libconfig;

class tcoinHandler : virtual public tcoinIf {
 private:
    tcoin_dal& dal;
    bool checkTocken(const std::string& tocken){
      return true;
    }

    tcoinException getInvalidTockenException(){
      tcoinException te;
      te.what = EXECUTION_FAILED;
      te.why = "Invalid tocken";
      return te;
    }
 public:
  tcoinHandler(tcoin_dal& _dal) : dal(_dal) {
    // Your initialization goes here
  }

  void getAccountInfo(ACC_INFO& _return, const std::string& tocken, const int32_t app, const int32_t uid) {
    // Your implementation goes here
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      _return=dal.tc_getAccount(uid, app);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      tcoinException te;
      te.what = EXECUTION_FAILED;
      te.why = ex.what();
      throw te;
    }
  }

  double getBalance(const std::string& tocken, const int32_t app, const int32_t uid) {
    // Your implementation goes here
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      ACC_INFO acc=dal.tc_getAccount(uid, app);
      if (acc.uid==0){
        tcoinException te;
        te.what = ACCOUNT_NOT_EXISTS;
        te.why = "Account does not exist";
        throw te;
      }
      return acc.balance;
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      tcoinException te;
      te.what = EXECUTION_FAILED;
      te.why = ex.what();
      throw te;
    }
    return 0;
  }

  int32_t createAccount(const std::string& tocken, const int32_t app, const int32_t uid, const std::string& name) {
    // Your implementation goes here
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      return dal.tc_createAccount(uid, app, name);
    }
    catch(std::exception& ex){
      tcoinException te;
      te.what = EXECUTION_FAILED;
      te.why = ex.what();
      throw te;
    }
    return 0;
  }

  int32_t cashIn(const std::string& tocken, const int32_t app, const int32_t uid, const double amount, const std::string& description) {
    // Your implementation goes here
    /*
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      return dal.tc_cashin(uid, app, amount, description);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      tcoinException te;
      te.what = EXECUTION_FAILED;
      te.why = ex.what();
      throw te;
    }
    */
    return cashIn2(tocken, app, uid, amount, description, 0);
  }

  int32_t cashIn2(const std::string& tocken, const int32_t app, const int32_t uid, const double amount, const std::string& description, const double promotion) {
    // Your implementation goes here
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      return dal.tc_cashin(uid, app, amount, description, promotion);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      tcoinException te;
      te.what = EXECUTION_FAILED;
      te.why = ex.what();
      throw te;
    }
    return 0;
  }

  int32_t transfer(const std::string& tocken, const int32_t app, const int32_t uid1, const int32_t uid2, const std::string& uname2, const double amount, const std::string& description) {
    // Your implementation goes here
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      if (uid1==uid2)
      {
        tcoinException te;
        te.what = EXECUTION_FAILED;
        te.why = "Could not transfer to the same account";
        throw te;
      }
      return dal.tc_transfer(app, uid1, uid2, uname2, amount, description);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      tcoinException te;
      te.what = EXECUTION_FAILED;
      te.why = ex.what();
      throw te;
    }
    return 0;
  }

  int32_t transfer2(const std::string& tocken, const int32_t app, const int32_t uid1, const int32_t uid2, const std::string& uname2, const double amount, const std::string& description, const double cost) {
    // Your implementation goes here
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      if (uid1==uid2)
      {
        tcoinException te;
        te.what = EXECUTION_FAILED;
        te.why = "Could not transfer to the same account";
        throw te;
      }
      return dal.tc_transfer2(app, uid1, uid2, uname2, amount, description, cost);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      tcoinException te;
      te.what = EXECUTION_FAILED;
      te.why = ex.what();
      throw te;
    }
    return 0;
  }

  int32_t exchange(const std::string& tocken, const int32_t app, const int32_t uid, const int to_app, const double amount, const std::string& description) {
    // Your implementation goes here
    /*
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      int app1=app;
      int app2=to_app;
      if (app1==app2){
        tcoinException te;
        te.what = EXECUTION_FAILED;
        te.why = "Could not exchange to the same app";
        throw te;
      }
      return dal.tc_exchange(uid, app1, app2, amount, description, 0);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      throw ex;
    }
    */
    return exchange2(tocken, app, uid, to_app, amount, description, 0);
  }

  int32_t exchange2(const std::string& tocken, const int32_t app, const int32_t uid, const int32_t to_app, const double amount, const std::string& description, const double promotion_amount) {
    // Your implementation goes here
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      int app1=app;
      int app2=to_app;
      if (app1==app2){
        tcoinException te;
        te.what = EXECUTION_FAILED;
        te.why = "Could not exchange to the same app";
        throw te;
      }
      return dal.tc_exchange(uid, app1, app2, amount, description, promotion_amount);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      throw ex;
    }
    return 0;
  }

  void searchUserTransaction(TRANS_DETAIL_RESULT& _return, const std::string& tocken, const int32_t app, const int32_t uid, const SEARCH_COND& cond, const int32_t page, const int32_t limit) {
    // Your implementation goes here
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      dal.tc_search_user_trans(_return, uid, app, cond, page, limit);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      throw ex;
    }
  }

  void getExchangeRate(EX_RATE& _return, const std::string& tocken, const int32_t app1, const int32_t app2){
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      _return=dal.tc_getExchangeRate(app1, app2);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      throw ex;
    }
  }

  void getUserAccountList(std::vector<ACC_INFO> & _return, const std::string& tocken, const int32_t uid) {
    // Your implementation goes here
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      dal.tc_getUserAccountList(_return, uid);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      throw ex;
    }
  }

  void getTransferableUserAccountList(std::vector<ACC_INFO> & _return, const std::string& tocken, const int32_t uid){
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      dal.tc_getTransferableUserAccountList(_return, uid);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      throw ex;
    }
  }

  void getAppInfo(APP_INFO& _return, const std::string& tocken, const int32_t app){
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      dal.tc_getAppInfo(_return, app);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      throw ex;
    }
  }

  void payment(std::map<int32_t, double> & _return, const std::string& tocken, const int32_t app, const std::vector<int32_t> & cre_uid, const std::vector<double> & cre_amt, const std::vector<std::string> & cre_desc, const std::vector<int32_t> & deb_uid, const std::vector<std::string> & deb_name, const std::vector<double> & deb_amt, const std::vector<std::string> & deb_desc) {
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      if (cre_uid.size()!=cre_amt.size() || cre_uid.size()!=cre_desc.size()){
        tcoinException te;
        te.what = INVALID_PARAM;
        te.why = "Credit uid, amount, description is not same size";
        throw te;
      }

      if (deb_uid.size()!=deb_amt.size() || deb_uid.size()!=deb_desc.size()){
        tcoinException te;
        te.what = INVALID_PARAM;
        te.why = "Debit uid, amount, description is not same size";
        throw te;
      }

      dal.tc_payment(_return, app, cre_uid, cre_amt, cre_desc, deb_uid, deb_name, deb_amt, deb_desc);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      throw ex;
    }
    return;
  }

  ACC_STATUS getAccountStatus(const std::string& tocken, const int32_t app, const int32_t uid) {
    // Your implementation goes here
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      return STATUS_ENABLED;
    }
    catch(std::exception& ex){
      throw ex;
    }
  }

  int32_t setAccountStatus(const std::string& tocken, const int32_t app, const int32_t uid, const ACC_STATUS status) {
    // Your implementation goes here
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      return dal.tc_setAccountStatus(uid, app, (int)status);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      printf("Error: %s\n", ex.what());
      throw ex;
    }
    return -1;
  }

  void searchTransaction(TRANS_SEARCH_RESULT& _return, const std::string& tocken, const SEARCH_COND& cond) {
    // Your implementation goes here
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      dal.tc_searchTransaction(_return, cond);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      printf("Error: %s\n", ex.what());
      throw ex;
    }
  }

  void searchAccount(ACC_SEARCH_RESULT& _return, const std::string& tocken, const SEARCH_COND& cond, const int32_t page, const int32_t limit) {
    // Your implementation goes here
    if (!checkTocken(tocken)){
      throw getInvalidTockenException();
    }
    try{
      dal.tc_searchAccount(_return, cond, page, limit);
    }
    catch(tcoinException& te){
      throw te;
    }
    catch(std::exception& ex){
      printf("Error: %s\n", ex.what());
      throw ex;
    }
  }
};

db_setting masterdb;
std::vector<db_setting> slavedb;
std::vector<mc_setting> mc;
int port=9090;
int thread_count=3;
int mc_enabled=0;
int mc_init_pool=5;
int mc_max_pool=5;

int read_config() {
    Config cfg;
    try{
      cfg.readFile("tcoin.cfg");
      Setting &root=cfg.getRoot();

      if (root.exists("port")){
        root.lookupValue("port", port);
      }

      if (root.exists("thread_count")){
        root.lookupValue("thread_count", thread_count);
      }

      if (!root.exists("masterdb")){
        printf("MasterDB settings not found\n");
        return -1;
      }
      Setting &master=root["masterdb"];

      master.lookupValue("server", masterdb.server);
      master.lookupValue("user", masterdb.user);
      master.lookupValue("password", masterdb.password);
      master.lookupValue("dbname", masterdb.dbname);

      if (!root.exists("slavedb")){
        printf("SlaveDB settings not found\n");
        return -1;
      }
      Setting &slave=root["slavedb"];
      for (int i=0; i<slave.getLength(); i++){
        db_setting db;
        Setting &s=slave[i];
        s.lookupValue("server", db.server);
        s.lookupValue("user", db.user);
        s.lookupValue("password", db.password);
        s.lookupValue("dbname", db.dbname);
        slavedb.insert(slavedb.begin(), db);
      }

      if (root.exists("mc_enabled")){
        root.lookupValue("mc_enabled", mc_enabled);
        if (mc_enabled!=0 && mc_enabled!=1){
          mc_enabled=0;
        }
      }

      if (mc_enabled==1){
        if (root.exists("mc_init_pool")){
          root.lookupValue("mc_init_pool", mc_init_pool);
          if (mc_init_pool<=0 || mc_init_pool>10){
            mc_init_pool=10;
          }
        }

        if (root.exists("mc_max_pool")){
          root.lookupValue("mc_max_pool", mc_max_pool);
          if (mc_max_pool<mc_init_pool){
            mc_max_pool=mc_init_pool;
          }
        }

        if (!root.exists("memcache")){
          printf("Memcache settings not found\n");
          return -1;
        }
        Setting &_mc=root["memcache"];
        for (int i=0; i<_mc.getLength(); i++){
          mc_setting m;
          Setting &s=_mc[i];
          s.lookupValue("server", m.server);
          s.lookupValue("port", m.port);
          mc.insert(mc.begin(), m);
        }
      }
    }
    catch(const FileIOException &fioex){
      return -10;
    }
    catch(const ParseException &pex){
      return -11;
    }
    return 0;
}

int main(int argc, char **argv) {
  int res=read_config();
  if (res<0){
    printf("Error when reading config file. Program exit\n");
    return res;
  }

  tcoinCache::singleton().init(mc_enabled==1, mc, mc_init_pool, mc_max_pool);
  tcoin_dal dal(masterdb, slavedb);

  shared_ptr<tcoinHandler> handler(new tcoinHandler(dal));

  shared_ptr<TProcessor> processor(new tcoinProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  shared_ptr<ThreadManager> thread_manager;
  if (thread_count>0){
    thread_manager = ThreadManager::
        newSimpleThreadManager(thread_count);
      shared_ptr<PosixThreadFactory> thread_factory(new PosixThreadFactory());
      thread_manager->threadFactory(thread_factory);
      thread_manager->start();
  }

  TNonblockingServer server(processor, protocolFactory, port, thread_manager);
  server.serve();

  return 0;
}
